---
title: 《算法 第四版》
link: learn_algorithm
date: 2018-06-01
categories: 学习
tags: [book]
---

## 前言

为什么要学习算法？

> 工作上需要飞机轮子，而市面上只有自行车轮子

从别人的经验中得到以下入门书籍。

- 算法设计与分析
- 算法引论
- Elements of Programming（编程原本）
- Writing Efficient Programs
- Alorithm Design Manual
- 编程珠玑 & 编程珠玑（续）
- MIT课程：[Advanced Data Structures](http://courses.csail.mit.edu/6.851/)

## 第一章：基础

JAVA语法，已了解，直接跳过

## 第二章：排序

- 选择排序：从左往右，交换当前索引和剩余数中最小值的位置
- 插入排序：将较大元素右移，移动距离为1，类似冒泡
- 希尔排序：基于插入排序，假设任意间隔h的元素都是有序的，较大元素移动的是h的距离（无法分析算法均值消耗）
- 快速排序：分治

## 第三章：查找

| 数据结构             | 优点                     | 缺点                                           |
| -------------------- | ------------------------ | ---------------------------------------------- |
| 链表（顺序查找）     | 适用于小型问题           | 慢                                             |
| 有序数组（二分查找） | 最优的查找效率和空间需求 | 插入慢                                         |
| 二叉查找树           | 实现简单                 | 性能无上界，链表需额外空间                     |
| 平衡二叉查找树       | 最优的查找效率和空间需求 | 链表需额外空间                                 |
| 散列表               | 快速查找和插入           | 需计算散列值，无法进行有序相关操作，需额外空间 |

## 图

- 定义
  - E（edege）：边
  - V（vertex）：顶点
  - v-w：连接v和w的边
- 定义

  - 图：由一个顶点和一组能够将两个顶点相连
  - 自环：一条连接一个顶点和自身的边
  - 平行边：连接同一对顶点
  - 多重图：含有平行边
  - 简单图：没有平行边或自环
- 定义

  - 路径：由边顺序连接的一些列顶点
  - 简单路径：没有重复顶点
  - 环：至少包含一条边其起点和终点相同的路径
  - 简单环：不含有重复顶点和边的环
  - 长度：路径或环包含的变数
- 定义

  - 连通：两个顶点之间存在一条连接对方的路径
  - 连通图：任意顶点都存在一条路径到达另一个任意顶点
  - 无环图：不包含环的图
- 定义

  - 树：无环连通图
  - 森林：互不相连的树的集合
  - 连通图生成树：含有连通图图的所有顶点，且是一个树
  - 生成数森林：所有连通图生成树的集合
  - 稀疏图和稠密图：由连接顶点数决定（无必然界限，一般应用面对的都是稀疏图）
  - 二分图：所有节点分成两部分，图连接的两个顶点都分别属于不同部分
- 定义
  - 邻接矩阵：V * V的布尔矩阵，当v和w相连，则定义v行w列的元素为true，否则，为false（无法表示平行边）
  - 边的数组：如：Edge，包含两个int实例（代表顶点）
  - 邻接表数组：一个顶点作索引

| 数据结构 | 所需空间 | 添加一条边 | 检查w和v是否相连 | 遍历v的所有相邻顶点 |
| -------- | -------- | ---------- | ---------------- | ------------------- |
| 边的列表 | E        | 1          | E                | E                   |
| 邻接矩阵 | V^2      | 1          | 1                | V                   |
| 邻接表   | E+V      | 1          | degree(v)        | degree(v)           |
| 邻接集   | E+V      | logV       | logV             | logV+degree(v)      |

- 定义

  - DFS：深度优先搜索

    - 具体化：走迷宫，绳子作用
    - 应用：寻找路径、检测环、是否是二分图（双色问题：能否仅用两种颜色对所有顶点着色，任意一边两断点颜色不同）
    - 耗费：与起点连通的所有顶点所需的时间和顶点的度数之和成正比

    ```java
    public static DepthFirstPaths {
        private boolean[] marked; // 该顶点是否吊用过dfs
        private int[] edgeTo; // 相连的顶顶啊
        private final int s; // 起点
        public DepthFirstPaths(Graph G, int s) {
            marked = new boolean[G.V()];
            edgeTo = new int[G.V()];
            this.s = s;
            dfs(G, s);
        }
        private void dfs(Graph G, int v) {
            marked[v] = true;
            for(int w: G.adj(v)) {
                if(!marked[2]) {
                    edgeTo[w] = v;
                    dfs(G, w);
                }
            }
        }
        public boolean hasPathTo(int v) {
            return marked[v];
        }
        public Iteerable<Integer> pathTo(int v) {
            if(!hasPathTo(v)) {
                return null;
            }
            Stack<Integer> path = new Stack<Integer>();
            for(int x=v; x!=s; x=edgeTo[x]) {
                path.push(x);
            }
            path.push(s);
            return path;
        }
    }
    ```

  - BFS：广度优先搜索

    - 应用：寻找最短路径
    - 耗费：最坏情况和V + E成正比

    ```java
    public class BreadthFirstPaths {
        private boolean[] marked;
        private int[] edgeTo;
        private final int s;
        public breadthFirstPaths(Graph G, int s) {
            marked = new boolean[G.V()];
            edgeTo = new int[G.V()]；
            this.s = s;
            bfs(G, s);
        }
        private void bfs(Graph G, int s) {
            Queue<Integer> queue = new Queue<Integer>();
            marked[s] = true; // 起点
            queue.enqueue(s); // 将其假如队列
            while(!queue.isEmpty) {
                int v = queue.deququqe();  // 从队列中删去
                for(int w : G.adj(v)) {
                    if(!marked[w]) { // 未标记的相邻顶点
                        edgeTo[w] = v;  // 保存最短路径的最后一条边
                        marked[w] = true; // 
                        queue.enqueue(w);
                    }
                }
            }
        }
        public boolean hasPathTo(int v) {
            return marked[v];
        }
        public Iterable<Integer> pathTo(int v) {
            // 同深度优先   
        }
    }
    ```

    