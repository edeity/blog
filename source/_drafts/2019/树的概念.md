---
title: 树【2018】
date: 1993-02-13
categories: 学习
tags: [react]
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

由于工作所用的技术较旧（Kero + ES5 + requirejs），和React无相关性，导致面试时问及React时，只知道用法而不知道具体原因，非常被动。值得注意，本文并不会讲解React的diff算法，你可以在[这里](http://www.infoq.com/cn/articles/react-dom-diff)了解react的diff：基于同层比较显著降低复杂度。

在这里仅记录一些树的基本概念。

## 基本概念

该小节将陆续整理react发布之初就提及的[树Diff算法](https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf)；

树的操作被归类为一下三种

- 标记（relabel）
- 删除（delete）
- 插入（insert）

由此衍生的其他操作：

- 树的编辑
- 树的对齐
- 树包括（Tree inclusion）

### 树的编辑

- `δ(T1, T2)` 最简单的方法是基于删除和插入操作，将树以某种序列方式遍历后，找出最右侧（基于遍历方式）不同点，以此为子树后，在此执行该方式，最后得到不同的最小子集。
  - 以拆分子问题的方式递归进行，其下限是由两颗树的size决定的，基于需要遍历的次数$$\sum_{k=0}^{|F|}k=O(|F|^2)$$，其对应的时间复杂度为$$O(|F_1|^2{|F_2|^2})$$
- 优化的算法是提前定义`keyroot`以中断后续比较（后续树会被折叠：cdepth(v)）使复杂度降为$$ O(|T_1||T_2|min \{ D_1, L_1 \} min \{ D_2, L_2 \}$$
- 令一个优化是确定区分左右树，以类二分法的方式来排除不需要比较的点，使复杂度下降为$$O(|T_1|T_2|log|T_2|)$$即某些文章所说的**不同子树的节点不会从一个子树迁移到另外一个子树上**

  ​



## 定义

其他关乎树的常规定义：

- `G`：几何体（graph）
  - `V(G)`：节点
  - `E(G)`：边


- `T`：有根的树（Tree）


- `root（T）`：树的根
- `|T|`：T的大小（指节点数）
- `deg(v)`： v节点的子节点数
- `depth(v)`：树的深度：v到root（T）的深度
- `leaves(T)`：T的叶子（无子节点的节点成为leaves）
  - 对于树T1，T2，deg(Ti)，depth(Ti)， deg(Ti) 会被简记`Li`，`Di`，`Ii，i=1,2`
- `θ`：empty tree
  - 如果`v ∈ V (T )，w ∈ V (T (v))` ，v是w的祖先
  - d if `w ∈V (T (v))\{v} `
- `parent(v)`：v的父节点，
- `pre(v)`：v的前序遍历编号
- `post(w)`：v的后续遍历编号
- `Σλ = Σ ∪λ`：不属于T的节点λ并入T
- `F`：T的集合，称为森林（Forest）
  - F(v) = F(v1, vi).
- `γ` : (Σλ ×Σλ)\(λ, λ) → R：是y一个距离度量（非最小）
  - `γ(l1, l2) ≥ 0, γ(l1, l1) = 0`
  - `γ(l1, l2) = γ(l2, l1)`
  - `γ(l1, l3) ≤ γ(l1, l2) + γ(l2, l3)`

树编辑定义

- `S`：T1 -> T2的操作集合
- `δ(F1, F2)` ：T1 -> T2 的最小操作消耗
- `(l1, l2)`：每一次的操作
- `δ(T1, T2)` = min{γ(S) | S is a sequence of operations transforming T1 into T2}：最小操作步骤
- `e(M, T1, T2)` ：edit distance mapping：树编辑的映射map
- $$γ(M)=\sum_{v,w\in{M}}γ(v→w)+\sum_{v\in{N_1}}γ(v→λ)+\sum_{w\in{N_2}}γ(λ→w)$$
- `δ(T1, T2)` = min{γ(M) | (M, T1, T2) is an edit distance mapping
- $$ M_1 ◦ M_2 = {(v, 2) \ | \ \exists{u}\in{V(T_2)}} \ such \ that \  (v, u)\in{M_1} \ and \ (u, w)\in{M_2} $$